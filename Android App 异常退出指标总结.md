>👉 在入职大厂稳定性组之后遇到了很多不了解的 异常退出指标，于是准备写一篇总结的文章
# Android 异常退出指标

- ### <u>***Java Crash***</u>
    "Java Crash" 是指在Java编程语言中，应用程序在运行过程中由于错误或异常而导致程序终止或崩溃的情况。Java程序的崩溃可能会导致程序无法正常运行，甚至可能引起系统的不稳定。

    Java Crash 可能由各种原因引起，例如：

    - **空指针引用（NullPointerException）**： 当尝试访问一个空对象引用（null引用）上的方法或属性时，会抛出空指针异常，导致程序崩溃。

    - **数组越界（ArrayIndexOutOfBoundsException）**： 当尝试访问数组中不存在的索引位置时，会抛出数组越界异常，导致程序崩溃。

    - **内存溢出（OutOfMemoryError）**： 当程序尝试分配更多内存资源而导致内存不足时，会抛出内存溢出异常，导致程序崩溃。

    - **未捕获的异常**： 如果程序中某个异常没有被适当地捕获和处理，它可能会传播到程序的顶层，并导致程序崩溃。

    - **栈溢出（StackOverflowError）**： 当递归函数调用层次太深，导致函数调用栈溢出时，会抛出栈溢出异常，导致程序崩溃。

    - **虚拟机错误**： 有时候虚拟机自身也可能遇到问题，例如无法启动、配置错误等，导致程序崩溃。

    为了避免 Java Crash，开发人员应该编写健壮的代码，正确地处理各种异常情况，避免空指针引用和数组越界等问题，进行适当的内存管理，避免递归调用过深，以及监控和调试程序以解决未知问题。使用适当的异常处理机制可以帮助程序更容易地从错误中恢复，而不是直接崩溃。
    ***
    <br>

- ### <u>***Native Crash***</U>
    Android Native Crash（本地崩溃）是指在Android应用程序中，由于本地代码（通常是C或C++代码）发生错误或异常而导致应用程序崩溃的情况。这种崩溃通常涉及应用程序的底层代码，如使用NDK编写的本地库。

    本地崩溃的可能原因有很多，以下是一些常见的原因：

    - **空指针引用（Null Pointer Dereference）**： 本地代码中使用了空指针，导致访问无效内存地址，触发崩溃。

    - **内存访问越界（Buffer Overflow）**： 本地代码中数组或缓冲区的访问超过了其范围，导致读写无效内存，引发崩溃。

     - **无效的内存释放（Invalid Memory Deallocation）**： 释放了已经被释放或不属于本地库管理的内存块，可能导致后续访问崩溃。

    - **多线程同步问题（Multithreading Issues）**： 多个线程并发执行本地代码，缺乏正确的同步机制可能导致数据竞争和崩溃。

    - **本地代码逻辑错误（Logic Errors in Native Code）**： 本地代码中的逻辑错误可能导致错误的计算或控制流程，从而引发崩溃。

    - **调用标准C库函数错误（Incorrect Use of Standard C Library Functions）**： 不正确地使用C标准库函数，如内存分配和字符串操作，可能引发崩溃。

    - **硬件相关问题（Hardware-related Issues）**： 涉及硬件资源的问题，如访问非法硬件寄存器，可能导致崩溃。

    - **调用Java代码错误（Incorrect Invocation of Java Code）**： 从本地代码中调用Java方法时的错误使用，可能导致崩溃。

    - **NDK版本兼容性问题（NDK Version Compatibility Issues）**： 使用不兼容的NDK版本或库可能导致崩溃。

    - **其他库的错误（Errors in Other Libraries）**： 本地代码使用的外部库可能存在错误，影响了应用程序的稳定性。

    为了解决本地崩溃问题，开发人员可以采取以下措施：
    - 仔细检查本地代码，避免使用空指针和无效的内存访问。
    - 使用适当的同步机制来处理多线程问题。正确释放内存，并避免出现内存泄漏。
    - 使用C和C++编码标准，避免常见的编程错误。
    - 使用调试工具和日志记录来追踪和诊断本地崩溃。
    - 在NDK的应用中，确保正确选择和配置NDK版本，以及依赖库的版本。
    - 在处理本地崩溃问题时，了解常见原因和采取适当的调试和优化措施是非常重要的。
    ***
    <br>

- ### <u> ***ANR (Application Not Response)*** </u>
    ANR（Application Not Responding）是指Android应用程序在一段时间内未能响应用户输入或操作的情况。当应用程序变得无法响应时，Android系统会认为应用程序出现了问题，并弹出一个ANR对话框，通知用户应用程序未响应。

    ANR可能由多种原因引起，以下是一些常见的原因：

    - **主线程阻塞**： 主线程是负责处理用户界面的线程。如果在主线程上执行了耗时操作，比如网络请求、数据库查询或复杂的计算，会导致主线程阻塞，从而使应用程序无法响应用户操作。

    - **长时间的I/O操作**： 当应用程序在主线程上执行长时间的I/O操作，如读写文件、数据库操作等，主线程会被阻塞，导致应用程序无法响应。

    - **死锁（Deadlock）**： 死锁是指多个线程互相等待对方释放锁的状态。如果发生死锁，线程无法继续执行，导致应用程序无法响应。

    - **UI线程上的耗时计算**： 如果在UI线程上执行复杂的计算，会导致UI线程阻塞，影响应用程序的响应性。

    - **未捕获的异常**： 如果在应用程序中某处发生未捕获的异常，会导致应用程序崩溃或阻塞，从而引发ANR。

    - **广播接收器阻塞**： 如果在广播接收器中执行耗时操作，可能会导致主线程阻塞，从而引发ANR。

    - **前台服务超时**： 前台服务在一定时间内未完成任务可能引发ANR。

     - **系统资源耗尽**： 如果应用程序占用了过多的内存、CPU等系统资源，可能导致系统资源不足，从而导致ANR。

    为了避免ANR问题，开发人员可以采取以下措施：
    - 在主线程上避免执行耗时操作，将耗时操作放在后台线程中进行。
    - 使用异步任务、线程池或Handler等机制来处理后台操作。
    - 使用适当的同步机制，避免发生死锁。
    - 使用异常处理机制捕获并处理异常，避免应用程序崩溃或阻塞。
    - 避免在广播接收器中执行耗时操作，尽量保持接收器的执行时间短暂。
    - 对于前台服务，确保在规定的时间内完成任务。
    - 对应用程序的资源使用进行优化，避免占用过多的系统资源。
    - 通过合理的设计和优化，可以有效减少ANR问题的出现，提升应用程序的响应性和用户体验。
    ***
    <br>

- ### <u> ***LMK (Low Memory Killer)***</u>
    LMK（Low Memory Killer）是Android操作系统中的一个重要组件，用于在系统内存不足时终止或杀死一些应用程序进程，以释放内存资源，从而防止系统崩溃或变得不稳定。LMK是Android系统的一种内存管理机制，旨在优化系统的性能和稳定性。

    LMK的主要原因在于系统内存有限，当多个应用程序同时运行并占用大量内存时，系统可能会出现内存不足的情况。这可能导致系统性能下降、应用程序响应变慢甚至崩溃。为了应对这种情况，LMK会监测系统内存的使用情况，并在内存资源不足时采取措施。

    LMK的工作原理如下：

    - **内存分级**： Android将系统内存划分为不同的级别，每个级别有不同的优先级。这些级别从低到高分为多个"类别"（category）。

    - **内存压力检测**： Android的内存管理系统会定期检测系统内存的压力情况。如果系统内存紧张，内存压力会增加。

    - **内存回收**： 当内存压力升高时，LMK会开始回收内存资源。它会优先终止优先级较低的应用程序进程，释放它们占用的内存。

    - **杀进程**： 如果内存压力继续增加，LMK可能会终止更多的应用程序进程，以释放更多的内存资源。这可能会影响到用户在后台运行的应用程序。

    需要注意的是，LMK的设计是为了维护系统的整体稳定性，而不是优先考虑单个应用程序的需求。这意味着，尽管LMK可以确保系统不会因为内存不足而崩溃，但在内存紧张的情况下，一些应用程序可能会被终止以释放资源。

    开发人员可以通过一些方法来减少应用程序被LMK终止的可能性，例如：
    - 使用适当的内存管理策略，避免内存泄漏和过度使用内存。
    - 使用合理的后台任务处理机制，避免占用过多的系统资源。
    - 避免在后台运行过多的进程或服务，以释放更多的内存资源给前台应用程序。
    - 使用适当的线程和进程管理，避免长时间运行的任务占用过多的内存。
     - 通过优化应用程序的内存使用和管理，开发人员可以减少LMK的影响，并提供更好的用户体验。
    ***
    <br>

- ### <u>***System Kill***</u>
    "System Kill" 是指 Android 系统在内存紧张的情况下，为了保证系统的稳定性和可用性，选择终止或杀死某些系统进程或服务的行为。这是一种内存管理策略，旨在防止系统耗尽内存资源而导致系统崩溃或不稳定。

    System Kill 的原因主要是出于系统内存不足的情况。当系统内存紧张，无法满足运行中应用程序和系统进程的内存需求时，系统会采取一些措施来释放内存资源，以防止系统的整体性能下降。System Kill 通常会优先终止一些优先级较低的系统进程，从而为重要的系统进程和前台应用程序腾出更多内存。

    System Kill 可能影响到一些系统功能和服务，如后台应用程序、系统服务以及一些不常用的进程。然而，系统会优先保留对用户界面、系统核心服务和正在交互的前台应用程序的支持，以确保用户体验和系统的稳定性。

    在 System Kill 的情况下，一些可能受影响的因素和原因包括：

    - **后台应用程序**： 优先终止后台运行的应用程序，释放它们占用的内存资源。
    - **系统服务**： 一些系统服务可能会被终止，导致某些功能受到影响。系统会优先保留核心的系统服务。
    - **不常用的进程**： 一些不常用的进程可能会被终止，以腾出内存。
    - **进程优先级**： 系统会根据进程的优先级来决定终止的顺序。优先级较低的进程可能更容易被终止。
    <br><br>
        
    需要注意的是，System Kill 是为了确保系统稳定性而采取的一种内存管理策略。在大多数情况下，用户可能不会察觉到 System Kill 的影响，因为系统会尽量保持核心功能和前台应用的正常运行。开发人员应该注意合理管理应用程序的内存使用，以减少被 System Kill 的可能性，并提供更好的用户体验。
    ***
    <br>

- ### <u>***SIGNALED***</u>
    在 Android 应用程序中，"Signaled异常退出" 是指应用程序在某些特定情况下收到操作系统信号（signal）而导致异常退出的情况。这些信号可能由操作系统或其他进程触发，通常表示了应用程序遇到了一些严重的问题或错误。这种异常退出可以导致应用程序崩溃、强制关闭或异常终止。

    在 Android 中，一些常见的导致 Signaled 异常退出的原因包括：

    - **SIGSEGV（Segmentation Violation）**： 这是一种段错误信号，表示应用程序试图访问无效的内存地址，通常由于内存访问越界或无效的指针引用导致。

    - **SIGABRT（Abort）**： 这是一种中止信号，通常是由于应用程序内部检测到了无法继续运行的错误，比如断言失败或其他逻辑错误。

    - **SIGILL（Illegal Instruction**： 这是一种非法指令信号，表示应用程序试图执行不合法的机器指令。

    - **SIGBUS（Bus Error）**： 这是一种总线错误信号，表示应用程序试图访问无效的内存地址，类似于 SIGSEGV。

    - **SIGFPE（Floating Point Exception）**： 这是一种浮点异常信号，表示应用程序执行了非法的浮点操作，如除以零或溢出。

    - **SIGTERM（Termination）**： 这是一种终止信号，通常用于表示应用程序被请求终止，可以由用户、系统或其他进程发起。

    - **其他信号**： 还有一些其他的信号，如 SIGHUP、SIGINT、SIGKILL 等，每个信号都有不同的含义和影响。

    这些信号可能是由应用程序内部错误、系统问题、库调用失败等多种原因引发的。在 Android 中，一旦应用程序收到了这些信号，通常会触发异常处理机制，有时可能会导致应用程序崩溃或被系统终止。对于某些信号，应用程序可能有机会进行一些清理操作，但有些信号是无法捕获或忽略的，如 SIGKILL。

    为了减少 Signaled 异常退出的发生，开发人员可以：

    - 编写健壮的代码，避免内存越界、非法指令和浮点异常等问题。
    - 使用适当的异常处理机制来捕获和处理可能出现的异常情况。
    - 进行严格的代码测试和质量控制，以发现并修复潜在的问题。
    - 避免在应用程序中使用无效的指针引用或未经初始化的变量。
    - 使用合适的错误处理和日志记录，以便能够追踪和调试异常情况。
    ***
    <br>

- ### <u> ***EXIT SELF*** </u>
    在 Android 应用程序开发中，"EXIT_SELF" 是指应用程序内部通过编程方式自行选择退出的行为。这意味着应用程序在特定条件下，主动调用代码来触发自身的退出操作，而不是被系统强制退出或由其他外部因素引起的。

    EXIT_SELF 的原因通常是由于特定的应用逻辑、用户需求或资源管理需要。以下是一些常见的情况和原因，导致 Android 应用程序可能选择进行 EXIT_SELF 操作：

    - **用户主动退出**： 应用程序内部提供了退出按钮或选项，让用户主动退出应用，通常通过调用 finish() 方法来实现。

    - **完成任务后退出**： 当应用程序完成某个任务、流程或操作后，根据业务需求，可能选择退出以提供一种流程的结束感。

    - **用户状态失效**： 在需要用户登录状态的应用中，如果用户登录状态失效（例如，登录过期），应用程序可能会选择退出，以确保用户数据的安全性。

    - **用户权限变更**： 如果用户权限发生变化，导致应用程序无法正常运行或提供所需的功能，可能会选择退出。

    - **资源管理**： 在资源紧张的情况下，应用程序可能会自行退出以释放资源，例如网络连接不可用、硬件支持不足等。

    - **应用设置**： 用户可能在应用设置中设置了特定的退出条件，当这些条件满足时，应用程序可能会执行退出操作。

    - **特殊场景处理**： 在某些情况下，应用程序可能会根据特殊的场景需求，如特定时间、地理位置等，选择退出。

    - **测试和调试**： 在测试和调试阶段，开发人员可能会在特定情况下触发退出操作以验证应用程序的行为。

    在实现 EXIT_SELF 操作时，开发人员应该确保在退出前进行必要的资源释放、数据保存、清理等操作，以确保退出过程的平稳和用户体验。同时，也需要考虑应用退出后的行为，如是否显示退出提示、保存用户数据等。

    总之，EXIT_SELF 是指应用程序自己选择退出，这在某些场景下可以用于提供更好的用户体验或满足业务需求。

以上就是总结的一些Android中的异常退出指标，如有错误欢迎各位大佬指正。