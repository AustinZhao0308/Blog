> 👉 接手了一个GWP-ASan相关的开发需求，但对ASan不是很了解，在网上查找ASan工具的相关知识后，发现并没有很清楚而统一的对多种ASan工具的变种的介绍，所以决定自己写一篇。
> 如果有不对的地方欢迎大家指正 🥹

# 各类ASan工具变种总结
### 1. ASan简介及面对的问题：

在使用高级编程语言 (这里主要指Java、Kotlin) 开发的时候，因为虚拟机的存在，所以我们往往不需要考虑内存访问相关的错误。但是一旦使用了一些底层编程语言 (比如C、C++等) ，来进行与操作系统或硬件直接的交互的底层的Native编程时，则可能会遇到更多的与内存访问相关的错误问题 (因为此时开发者可能需要自行负责内存的分配、释放、访问等，而不是由高级语言进行自动内存管理) 。
这些错误问题主要包含了：
1. **内存泄漏**：不正确的内存分配和释放可能导致内存泄漏，使应用的内存占用不断增加，最终导致应用崩溃或性能下降。
2. **野指针和悬空指针**：在C/C++中，开发者需要手动管理指针，而不当地使用野指针或悬空指针可能导致未定义的行为、崩溃或数据损坏。
3. **缓冲区溢出**：对于数组或缓冲区的访问不当可能导致缓冲区溢出，从而覆盖其他内存区域的数据，引发各种问题，包括安全漏洞。
4. **并发和线程安全性**：底层编程可能涉及多线程编程，需要处理并发和线程安全性问题，如竞态条件、死锁等。
5. **性能优化和调试**：底层编程的性能和调试要求可能更高，需要更深入的优化技巧和工具。

这些错误会引发很多应用使用上的问题甚至是安全问题，而且往往很难与排查，所以产生了很多处理此类问题的工具，ASan就是其中的一种。本篇博客中我们主要介绍ASan及其两种变体HWASan以及GWP-ASan。

### 2. ASan的原理解析
ASan的全名叫做 Address Sanitizer。我们先来笼统的了解一下它的基本工作过程：
1. **编译时插桩**：
在代码编译阶段，ASan使用[编译器插桩技术](https://akinian.fandom.com/zh/wiki/%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%92%E6%A1%A9%E6%8A%80%E6%9C%AF?venotify=created)将原始代码进行修改，以在运行时进行内存访问检查。这意味着生成的可执行文件会包含额外的代码，用于记录和检测内存访问操作。
2. **内存布局重排**：
ASan会重新安排程序的内存布局，以便有效地检测内存访问错误。它在每个分配的内存块之前和之后插入“红区”（Redzone） - 一段附加内存，用于检测缓冲区溢出。如果程序尝试访问红区，ASan会立即报告错误。
3. **元数据存储**：
ASan会维护元数据（metadata）来跟踪分配的内存块信息。这些元数据存储在与内存块一起分配的内存块中，并记录有关块的大小、状态等信息。这些信息有助于检测释放后的内存访问错误。
4. **运行时检查**：
当程序运行时，插入的ASan代码会在每个内存访问操作（读取或写入）之前和之后执行。它会检查目标内存是否位于合法的范围内，以及是否与其他内存块重叠。如果发现内存访问错误，ASan会触发报告，并指出错误发生的位置、类型和详细信息。
5. **报告生成**：
当ASan检测到内存错误时，它会生成一个详细的报告，包括错误类型、错误位置、堆栈跟踪等信息。这些报告可以帮助开发者定位和修复问题。

总结的说，ASan主要由两部分工具组成：




## 参考文献

1. https://cloud.tencent.com/developer/article/1657154
2. https://akinian.fandom.com/zh/wiki/%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%92%E6%A1%A9%E6%8A%80%E6%9C%AF
3. 